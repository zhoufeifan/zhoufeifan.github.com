<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>执行上下文类型 | 周非凡个人博客</title>
    <meta name="description" content="Vue 驱动的静态网站生成器">
    
    
    <link rel="preload" href="/assets/css/0.styles.d01e3fed.css" as="style"><link rel="preload" href="/assets/js/app.c9da9db2.js" as="script"><link rel="preload" href="/assets/js/2.febc0262.js" as="script"><link rel="preload" href="/assets/js/17.38b70eaf.js" as="script"><link rel="prefetch" href="/assets/js/10.0253064e.js"><link rel="prefetch" href="/assets/js/11.175002a3.js"><link rel="prefetch" href="/assets/js/12.c9c2623b.js"><link rel="prefetch" href="/assets/js/13.a252b052.js"><link rel="prefetch" href="/assets/js/14.6a53dc1e.js"><link rel="prefetch" href="/assets/js/15.84088994.js"><link rel="prefetch" href="/assets/js/16.09fbb166.js"><link rel="prefetch" href="/assets/js/18.24a31878.js"><link rel="prefetch" href="/assets/js/19.e58abf47.js"><link rel="prefetch" href="/assets/js/20.a4e1f7ec.js"><link rel="prefetch" href="/assets/js/21.520b96e8.js"><link rel="prefetch" href="/assets/js/22.8455ead8.js"><link rel="prefetch" href="/assets/js/23.012b6e4c.js"><link rel="prefetch" href="/assets/js/24.90bca786.js"><link rel="prefetch" href="/assets/js/25.0b9867c9.js"><link rel="prefetch" href="/assets/js/26.5835b50d.js"><link rel="prefetch" href="/assets/js/27.90bf64b9.js"><link rel="prefetch" href="/assets/js/28.8b2856a2.js"><link rel="prefetch" href="/assets/js/29.4f0f0797.js"><link rel="prefetch" href="/assets/js/3.b8e8b8dc.js"><link rel="prefetch" href="/assets/js/30.ec214258.js"><link rel="prefetch" href="/assets/js/31.19d008c9.js"><link rel="prefetch" href="/assets/js/32.e2e7fb69.js"><link rel="prefetch" href="/assets/js/33.e7250e7c.js"><link rel="prefetch" href="/assets/js/34.6af80751.js"><link rel="prefetch" href="/assets/js/35.8c6fd912.js"><link rel="prefetch" href="/assets/js/36.abacb260.js"><link rel="prefetch" href="/assets/js/37.872fafd6.js"><link rel="prefetch" href="/assets/js/38.c11a6237.js"><link rel="prefetch" href="/assets/js/39.0251e2ab.js"><link rel="prefetch" href="/assets/js/4.a97bd63a.js"><link rel="prefetch" href="/assets/js/40.490030c9.js"><link rel="prefetch" href="/assets/js/41.ae009df1.js"><link rel="prefetch" href="/assets/js/42.733a49d6.js"><link rel="prefetch" href="/assets/js/43.6b0719ec.js"><link rel="prefetch" href="/assets/js/44.8abd3659.js"><link rel="prefetch" href="/assets/js/45.7e9da5d6.js"><link rel="prefetch" href="/assets/js/46.69831b02.js"><link rel="prefetch" href="/assets/js/47.0187e2c6.js"><link rel="prefetch" href="/assets/js/48.d573af72.js"><link rel="prefetch" href="/assets/js/49.c0de9630.js"><link rel="prefetch" href="/assets/js/5.9f3cace6.js"><link rel="prefetch" href="/assets/js/50.dd93629a.js"><link rel="prefetch" href="/assets/js/51.0de94388.js"><link rel="prefetch" href="/assets/js/52.f40156a5.js"><link rel="prefetch" href="/assets/js/53.cd0087a3.js"><link rel="prefetch" href="/assets/js/54.dc27779e.js"><link rel="prefetch" href="/assets/js/55.e83361b5.js"><link rel="prefetch" href="/assets/js/56.e98fbba1.js"><link rel="prefetch" href="/assets/js/57.29f5154b.js"><link rel="prefetch" href="/assets/js/58.2a266b80.js"><link rel="prefetch" href="/assets/js/59.a0a6d426.js"><link rel="prefetch" href="/assets/js/6.ea94c1bd.js"><link rel="prefetch" href="/assets/js/60.431c1ff3.js"><link rel="prefetch" href="/assets/js/61.f3c25606.js"><link rel="prefetch" href="/assets/js/62.df795bbf.js"><link rel="prefetch" href="/assets/js/7.954bbdf7.js"><link rel="prefetch" href="/assets/js/8.5ac09073.js"><link rel="prefetch" href="/assets/js/9.1c3b9112.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d01e3fed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/css/1.html" class="sidebar-link">css 常用知识点</a></li><li><a href="/doc/css/2.html" class="sidebar-link">清除浮动</a></li><li><a href="/doc/css/3.html" class="sidebar-link">三大经典问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/html/1.html" class="sidebar-link">浏览器解析流程</a></li><li><a href="/doc/html/2.html" class="sidebar-link">viewport原理</a></li><li><a href="/doc/html/3.html" class="sidebar-link">meta标签</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/js/1-1.html" class="active sidebar-link">堆栈调用（上篇）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/doc/js/1-2.html" class="sidebar-link">堆栈调用（下篇）</a></li><li><a href="/doc/js/2.html" class="sidebar-link">作用域与闭包</a></li><li><a href="/doc/js/3.html" class="sidebar-link">this绑定解析</a></li><li><a href="/doc/js/4-1.html" class="sidebar-link">call、apply原理与使用场景</a></li><li><a href="/doc/js/4-2.html" class="sidebar-link">bind 的原理与使用场景</a></li><li><a href="/doc/js/5-1.html" class="sidebar-link">浅拷贝概念以及实现原理</a></li><li><a href="/doc/js/5-2.html" class="sidebar-link">深拷贝概念以及实现原理</a></li><li><a href="/doc/js/6-1.html" class="sidebar-link">原型与继承之基本概念</a></li><li><a href="/doc/js/6-2.html" class="sidebar-link">原型与继承之（6种继承方案）</a></li><li><a href="/doc/js/7.html" class="sidebar-link">事件机制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工具函数 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/utils/1.html" class="sidebar-link">常见的JS方法</a></li><li><a href="/doc/utils/2.html" class="sidebar-link">常见的正则表达式</a></li><li><a href="/doc/utils/3.html" class="sidebar-link">常用的时间处理方法</a></li><li><a href="/doc/utils/4.html" class="sidebar-link">常用的金额处理方法</a></li><li><a href="/doc/utils/5.html" class="sidebar-link">继承和原型链demo</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTTP 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/http/1.html" class="sidebar-link">常见的14种响应状态码</a></li><li><a href="/doc/http/2.html" class="sidebar-link">Http首部字段</a></li><li><a href="/doc/http/3.html" class="sidebar-link">Https介绍</a></li><li><a href="/doc/http/4.html" class="sidebar-link">Web的攻击技术</a></li><li><a href="/doc/http/5.html" class="sidebar-link">Http 发展历史</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/vue/1.html" class="sidebar-link">Vue 双向绑定的原理</a></li><li><a href="/doc/vue/2.html" class="sidebar-link">Vue 踩坑总结</a></li><li><a href="/doc/vue/3.html" class="sidebar-link">Vue 生命周期详解</a></li><li><a href="/doc/vue/4.html" class="sidebar-link">Vuex 基本用法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node 专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/node/1.html" class="sidebar-link">用node撸一个前端自动化发布工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>项目总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc/project/1.html" class="sidebar-link">H5项目总结</a></li><li><a href="/doc/project/2.html" class="sidebar-link">首页优化项目总结</a></li><li><a href="/doc/project/3.html" class="sidebar-link">vue 输入限制</a></li><li><a href="/doc/project/4.html" class="sidebar-link">搜车库项目总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="执行上下文类型"><a href="#执行上下文类型" aria-hidden="true" class="header-anchor">#</a> 执行上下文类型</h3> <ul><li>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。</li> <li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</li> <li>Eval 函数执行上下文 （不建议使用）</li></ul> <h3 id="执行栈"><a href="#执行栈" aria-hidden="true" class="header-anchor">#</a> 执行栈</h3> <p>又名调用栈，用于存储在代码执行期间创建的所有执行上下文。</p> <p>首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p> <p>当栈顶的函数执行完毕后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p> <h3 id="执行上下文的创建"><a href="#执行上下文的创建" aria-hidden="true" class="header-anchor">#</a> 执行上下文的创建</h3> <ul><li>创建阶段</li> <li>执行阶段</li></ul> <h3 id="创建阶段"><a href="#创建阶段" aria-hidden="true" class="header-anchor">#</a> 创建阶段</h3> <h4 id="_1、确定-this-的值，也被称为-this-binding。"><a href="#_1、确定-this-的值，也被称为-this-binding。" aria-hidden="true" class="header-anchor">#</a> 1、确定 this 的值，也被称为 This Binding。</h4> <ul><li>全局执行上下文中，this指向全局对象, 浏览器中为window, node 中指向这个文件的 module 对象。</li> <li>函数执行上下文中，this 的值取决于函数的调用方式。</li></ul> <h4 id="_2、确定-lexicalenvironment（词法环境）"><a href="#_2、确定-lexicalenvironment（词法环境）" aria-hidden="true" class="header-anchor">#</a> 2、确定 LexicalEnvironment（词法环境）</h4> <p><strong>1、组成部分</strong></p> <ul><li>环境记录：存储变量和函数声明的实际位置</li> <li>对外部环境的引用：可以访问其外部词法环境</li></ul> <p><strong>2、类型</strong></p> <ul><li>全局环境，没有外部环境，外部引用为null。可以访问全局对象、用户定义的全局变量、方法，this指向全局对象。</li> <li>函数环境，用户在函数中定义的变量被存储在环境记录中，也包含arguments对象，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li></ul> <h4 id="_3、确定-variableenvironment（变量环境）"><a href="#_3、确定-variableenvironment（变量环境）" aria-hidden="true" class="header-anchor">#</a> 3、确定 VariableEnvironment（变量环境）</h4> <p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。<br>
在 ES6 中，<strong>词法环境</strong>和<strong>变量环境</strong>的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储变量（var）绑定。</p> <h3 id="执行阶段"><a href="#执行阶段" aria-hidden="true" class="header-anchor">#</a> 执行阶段</h3> <p>此阶段，完成对所有变量的分配，最后执行代码。</p> <h3 id="常见面试题"><a href="#常见面试题" aria-hidden="true" class="header-anchor">#</a> 常见面试题</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>x     <span class="token comment">// 这时 a.x 的值是多少</span>
b<span class="token punctuation">.</span>x     <span class="token comment">// 这时 b.x 的值是多少</span>
</code></pre></div><h4 id="_1、优先级。"><a href="#_1、优先级。" aria-hidden="true" class="header-anchor">#</a> 1、优先级。</h4> <p>.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。</p> <h4 id="_2、赋值操作是从右到左"><a href="#_2、赋值操作是从右到左" aria-hidden="true" class="header-anchor">#</a> 2、赋值操作是从右到左</h4> <p>所以先执行a = {n:2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}对象中的undefined，其实就是b.x，相当于b.x = {n: 2}</p> <h3 id="类型与方法"><a href="#类型与方法" aria-hidden="true" class="header-anchor">#</a> 类型与方法</h3> <h4 id="值类型（stack栈）"><a href="#值类型（stack栈）" aria-hidden="true" class="header-anchor">#</a> 值类型（stack栈）</h4> <p>Undefined、Null、Boolean、Number、String、Symbol（es6新增）</p> <h4 id="引用类型（heap堆）"><a href="#引用类型（heap堆）" aria-hidden="true" class="header-anchor">#</a> 引用类型（heap堆）</h4> <p>Object Array Date RegExp Function</p> <h4 id="内置类型"><a href="#内置类型" aria-hidden="true" class="header-anchor">#</a> 内置类型</h4> <p>null undefined boolean number string object symbol</p> <h4 id="内置对象"><a href="#内置对象" aria-hidden="true" class="header-anchor">#</a> 内置对象</h4> <p>Object、Function、Array、String、Boolean、Number、Math、Date、RegExp、JSON、Error</p> <p><strong>es6新增</strong><br>
Promise Symbol Set</p> <h4 id="内置方法"><a href="#内置方法" aria-hidden="true" class="header-anchor">#</a> 内置方法</h4> <ul><li>isFinite</li> <li>isNaN</li> <li>parseInt</li> <li>parseFloat</li></ul> <h4 id="undefined-和-null-的区别"><a href="#undefined-和-null-的区别" aria-hidden="true" class="header-anchor">#</a> undefined 和 null 的区别</h4> <ul><li>undefined 表示声明了一个未定义的变量</li> <li>null 表示为空（没有对象）</li></ul> <h4 id="如何判断一个变量是array类型？如何判断一个变量是number类型？（都不止一种）"><a href="#如何判断一个变量是array类型？如何判断一个变量是number类型？（都不止一种）" aria-hidden="true" class="header-anchor">#</a> 如何判断一个变量是Array类型？如何判断一个变量是Number类型？（都不止一种）</h4> <ul><li>type of 1 //number</li> <li>[] instanceof Array; // true</li> <li>Object.prototype.toString.call(1) ;    // [object Number]</li></ul> <h4 id="typeof-介绍"><a href="#typeof-介绍" aria-hidden="true" class="header-anchor">#</a> typeof 介绍</h4> <ul><li>typeof null =&gt; object</li> <li>000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object</li> <li>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</li> <li>typeof 对于引用类型来说，除了函数都会显示 object</li></ul> <h3 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h3> <p><strong>首先我们要知道，在 JS 中类型转换只有三种情况，分别是</strong></p> <ul><li>转换为布尔值</li> <li>转换为数字</li> <li>转换为字符串</li></ul> <h4 id="我们先来看一个类型转换表格"><a href="#我们先来看一个类型转换表格" aria-hidden="true" class="header-anchor">#</a> 我们先来看一个类型转换表格</h4> <p><img src="http://image.zhoufeifan.tech/blog/js/1/1-1.jpg" alt="image"></p> <h4 id="转boolean"><a href="#转boolean" aria-hidden="true" class="header-anchor">#</a> 转Boolean</h4> <p>在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象</p> <h4 id="对象转原始类型"><a href="#对象转原始类型" aria-hidden="true" class="header-anchor">#</a> 对象转原始类型</h4> <p>对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：</p> <ul><li>如果已经是原始类型了，那就不需要转换了</li> <li>调用 x.valueOf()，如果转换为基础类型，就返回转换的值</li> <li>调用 x.toString()，如果转换为基础类型，就返回转换的值</li> <li>如果都没有返回原始类型，就会报错</li></ul> <h4 id="比较时的类型转化"><a href="#比较时的类型转化" aria-hidden="true" class="header-anchor">#</a> == 比较时的类型转化</h4> <p><img src="http://image.zhoufeifan.tech/blog/js/1/1-2.png" alt="image"></p> <p>为什么下面这个比较输出为true</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">说明</p> <p>因为![] 被转为了布尔值false，变为 [] == false， boolean 转化为number 被转为了[] == 0 ，<br>
[] 为object 也会转化为 number 进行比较 ， 因此最终变为 0 == 0</p></div> <h3 id="常用api"><a href="#常用api" aria-hidden="true" class="header-anchor">#</a> 常用API</h3> <h4 id="常用的字符串api"><a href="#常用的字符串api" aria-hidden="true" class="header-anchor">#</a> 常用的字符串api</h4> <ul><li>replace match</li> <li>slice split</li> <li>substr substring</li> <li>valueOf toString</li></ul> <h4 id="常用的数组api"><a href="#常用的数组api" aria-hidden="true" class="header-anchor">#</a> 常用的数组api</h4> <ul><li>some every</li> <li>sort</li> <li>map</li> <li>join</li> <li>find</li> <li>forEach</li> <li>filter</li> <li>push pop</li> <li>splice array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/doc/html/3.html" class="prev">
          meta标签
        </a></span> <span class="next"><a href="/doc/js/1-2.html">
          堆栈调用（下篇）
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c9da9db2.js" defer></script><script src="/assets/js/2.febc0262.js" defer></script><script src="/assets/js/17.38b70eaf.js" defer></script>
  </body>
</html>
