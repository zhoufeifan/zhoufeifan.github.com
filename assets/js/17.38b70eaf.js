(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{199:function(a,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h3",{attrs:{id:"执行上下文类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 执行上下文类型")]),a._v(" "),r("ul",[r("li",[a._v("全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。")]),a._v(" "),r("li",[a._v("函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。")]),a._v(" "),r("li",[a._v("Eval 函数执行上下文 （不建议使用）")])]),a._v(" "),r("h3",{attrs:{id:"执行栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行栈","aria-hidden":"true"}},[a._v("#")]),a._v(" 执行栈")]),a._v(" "),r("p",[a._v("又名调用栈，用于存储在代码执行期间创建的所有执行上下文。")]),a._v(" "),r("p",[a._v("首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。")]),a._v(" "),r("p",[a._v("当栈顶的函数执行完毕后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。")]),a._v(" "),r("h3",{attrs:{id:"执行上下文的创建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文的创建","aria-hidden":"true"}},[a._v("#")]),a._v(" 执行上下文的创建")]),a._v(" "),r("ul",[r("li",[a._v("创建阶段")]),a._v(" "),r("li",[a._v("执行阶段")])]),a._v(" "),r("h3",{attrs:{id:"创建阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建阶段","aria-hidden":"true"}},[a._v("#")]),a._v(" 创建阶段")]),a._v(" "),r("h4",{attrs:{id:"_1、确定-this-的值，也被称为-this-binding。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、确定-this-的值，也被称为-this-binding。","aria-hidden":"true"}},[a._v("#")]),a._v(" 1、确定 this 的值，也被称为 This Binding。")]),a._v(" "),r("ul",[r("li",[a._v("全局执行上下文中，this指向全局对象, 浏览器中为window, node 中指向这个文件的 module 对象。")]),a._v(" "),r("li",[a._v("函数执行上下文中，this 的值取决于函数的调用方式。")])]),a._v(" "),r("h4",{attrs:{id:"_2、确定-lexicalenvironment（词法环境）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、确定-lexicalenvironment（词法环境）","aria-hidden":"true"}},[a._v("#")]),a._v(" 2、确定 LexicalEnvironment（词法环境）")]),a._v(" "),r("p",[r("strong",[a._v("1、组成部分")])]),a._v(" "),r("ul",[r("li",[a._v("环境记录：存储变量和函数声明的实际位置")]),a._v(" "),r("li",[a._v("对外部环境的引用：可以访问其外部词法环境")])]),a._v(" "),r("p",[r("strong",[a._v("2、类型")])]),a._v(" "),r("ul",[r("li",[a._v("全局环境，没有外部环境，外部引用为null。可以访问全局对象、用户定义的全局变量、方法，this指向全局对象。")]),a._v(" "),r("li",[a._v("函数环境，用户在函数中定义的变量被存储在环境记录中，也包含arguments对象，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。")])]),a._v(" "),r("h4",{attrs:{id:"_3、确定-variableenvironment（变量环境）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、确定-variableenvironment（变量环境）","aria-hidden":"true"}},[a._v("#")]),a._v(" 3、确定 VariableEnvironment（变量环境）")]),a._v(" "),r("p",[a._v("变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。"),r("br"),a._v("\n在 ES6 中，"),r("strong",[a._v("词法环境")]),a._v("和"),r("strong",[a._v("变量环境")]),a._v("的区别在于前者用于存储"),r("strong",[a._v("函数声明和变量")]),a._v("（ let 和 const ）绑定，而后者仅用于存储变量（var）绑定。")]),a._v(" "),r("h3",{attrs:{id:"执行阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行阶段","aria-hidden":"true"}},[a._v("#")]),a._v(" 执行阶段")]),a._v(" "),r("p",[a._v("此阶段，完成对所有变量的分配，最后执行代码。")]),a._v(" "),r("h3",{attrs:{id:"常见面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见面试题")]),a._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" b "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\na"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("x "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\na"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("x     "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 这时 a.x 的值是多少")]),a._v("\nb"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("x     "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 这时 b.x 的值是多少")]),a._v("\n")])])]),r("h4",{attrs:{id:"_1、优先级。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、优先级。","aria-hidden":"true"}},[a._v("#")]),a._v(" 1、优先级。")]),a._v(" "),r("p",[a._v(".的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。")]),a._v(" "),r("h4",{attrs:{id:"_2、赋值操作是从右到左"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、赋值操作是从右到左","aria-hidden":"true"}},[a._v("#")]),a._v(" 2、赋值操作是从右到左")]),a._v(" "),r("p",[a._v("所以先执行a = {n:2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}对象中的undefined，其实就是b.x，相当于b.x = {n: 2}")]),a._v(" "),r("h3",{attrs:{id:"类型与方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型与方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 类型与方法")]),a._v(" "),r("h4",{attrs:{id:"值类型（stack栈）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#值类型（stack栈）","aria-hidden":"true"}},[a._v("#")]),a._v(" 值类型（stack栈）")]),a._v(" "),r("p",[a._v("Undefined、Null、Boolean、Number、String、Symbol（es6新增）")]),a._v(" "),r("h4",{attrs:{id:"引用类型（heap堆）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用类型（heap堆）","aria-hidden":"true"}},[a._v("#")]),a._v(" 引用类型（heap堆）")]),a._v(" "),r("p",[a._v("Object Array Date RegExp Function")]),a._v(" "),r("h4",{attrs:{id:"内置类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内置类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 内置类型")]),a._v(" "),r("p",[a._v("null undefined boolean number string object symbol")]),a._v(" "),r("h4",{attrs:{id:"内置对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内置对象","aria-hidden":"true"}},[a._v("#")]),a._v(" 内置对象")]),a._v(" "),r("p",[a._v("Object、Function、Array、String、Boolean、Number、Math、Date、RegExp、JSON、Error")]),a._v(" "),r("p",[r("strong",[a._v("es6新增")]),r("br"),a._v("\nPromise Symbol Set")]),a._v(" "),r("h4",{attrs:{id:"内置方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内置方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 内置方法")]),a._v(" "),r("ul",[r("li",[a._v("isFinite")]),a._v(" "),r("li",[a._v("isNaN")]),a._v(" "),r("li",[a._v("parseInt")]),a._v(" "),r("li",[a._v("parseFloat")])]),a._v(" "),r("h4",{attrs:{id:"undefined-和-null-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#undefined-和-null-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" undefined 和 null 的区别")]),a._v(" "),r("ul",[r("li",[a._v("undefined 表示声明了一个未定义的变量")]),a._v(" "),r("li",[a._v("null 表示为空（没有对象）")])]),a._v(" "),r("h4",{attrs:{id:"如何判断一个变量是array类型？如何判断一个变量是number类型？（都不止一种）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个变量是array类型？如何判断一个变量是number类型？（都不止一种）","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何判断一个变量是Array类型？如何判断一个变量是Number类型？（都不止一种）")]),a._v(" "),r("ul",[r("li",[a._v("type of 1 //number")]),a._v(" "),r("li",[a._v("[] instanceof Array; // true")]),a._v(" "),r("li",[a._v("Object.prototype.toString.call(1) ;    // [object Number]")])]),a._v(" "),r("h4",{attrs:{id:"typeof-介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typeof-介绍","aria-hidden":"true"}},[a._v("#")]),a._v(" typeof 介绍")]),a._v(" "),r("ul",[r("li",[a._v("typeof null => object")]),a._v(" "),r("li",[a._v("000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object")]),a._v(" "),r("li",[a._v("typeof 对于原始类型来说，除了 null 都可以显示正确的类型")]),a._v(" "),r("li",[a._v("typeof 对于引用类型来说，除了函数都会显示 object")])]),a._v(" "),r("h3",{attrs:{id:"类型转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型转换","aria-hidden":"true"}},[a._v("#")]),a._v(" 类型转换")]),a._v(" "),r("p",[r("strong",[a._v("首先我们要知道，在 JS 中类型转换只有三种情况，分别是")])]),a._v(" "),r("ul",[r("li",[a._v("转换为布尔值")]),a._v(" "),r("li",[a._v("转换为数字")]),a._v(" "),r("li",[a._v("转换为字符串")])]),a._v(" "),r("h4",{attrs:{id:"我们先来看一个类型转换表格"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我们先来看一个类型转换表格","aria-hidden":"true"}},[a._v("#")]),a._v(" 我们先来看一个类型转换表格")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://image.zhoufeifan.tech/blog/js/1/1-1.jpg",alt:"image"}})]),a._v(" "),r("h4",{attrs:{id:"转boolean"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#转boolean","aria-hidden":"true"}},[a._v("#")]),a._v(" 转Boolean")]),a._v(" "),r("p",[a._v("在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象")]),a._v(" "),r("h4",{attrs:{id:"对象转原始类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象转原始类型")]),a._v(" "),r("p",[a._v("对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：")]),a._v(" "),r("ul",[r("li",[a._v("如果已经是原始类型了，那就不需要转换了")]),a._v(" "),r("li",[a._v("调用 x.valueOf()，如果转换为基础类型，就返回转换的值")]),a._v(" "),r("li",[a._v("调用 x.toString()，如果转换为基础类型，就返回转换的值")]),a._v(" "),r("li",[a._v("如果都没有返回原始类型，就会报错")])]),a._v(" "),r("h4",{attrs:{id:"比较时的类型转化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#比较时的类型转化","aria-hidden":"true"}},[a._v("#")]),a._v(" == 比较时的类型转化")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://image.zhoufeifan.tech/blog/js/1/1-2.png",alt:"image"}})]),a._v(" "),r("p",[a._v("为什么下面这个比较输出为true")]),a._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[a._v("console"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n")])])]),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[a._v("说明")]),a._v(" "),r("p",[a._v("因为![] 被转为了布尔值false，变为 [] == false， boolean 转化为number 被转为了[] == 0 ，"),r("br"),a._v("\n[] 为object 也会转化为 number 进行比较 ， 因此最终变为 0 == 0")])]),a._v(" "),r("h3",{attrs:{id:"常用api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用api","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用API")]),a._v(" "),r("h4",{attrs:{id:"常用的字符串api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用的字符串api","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用的字符串api")]),a._v(" "),r("ul",[r("li",[a._v("replace match")]),a._v(" "),r("li",[a._v("slice split")]),a._v(" "),r("li",[a._v("substr substring")]),a._v(" "),r("li",[a._v("valueOf toString")])]),a._v(" "),r("h4",{attrs:{id:"常用的数组api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用的数组api","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用的数组api")]),a._v(" "),r("ul",[r("li",[a._v("some every")]),a._v(" "),r("li",[a._v("sort")]),a._v(" "),r("li",[a._v("map")]),a._v(" "),r("li",[a._v("join")]),a._v(" "),r("li",[a._v("find")]),a._v(" "),r("li",[a._v("forEach")]),a._v(" "),r("li",[a._v("filter")]),a._v(" "),r("li",[a._v("push pop")]),a._v(" "),r("li",[a._v("splice array.splice(start[, deleteCount[, item1[, item2[, ...]]]])")])])])},[],!1,null,null,null);t.default=s.exports}}]);