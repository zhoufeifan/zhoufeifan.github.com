(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{198:function(t,a,e){"use strict";e.r(a);var r=e(0),i=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"http-1-x-的缺陷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-x-的缺陷","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP/1.x 的缺陷")]),t._v(" "),e("ul",[e("li",[t._v("链接无法复用，每次启动 TCP 链接时都要经历三次握手")]),t._v(" "),e("li",[t._v("HTTP/1.1虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个connection。 且 keep-alive 如果长时间存在会耗费资源，给服务器带来性能压力。因此 keep-alive 需要及时释放掉。")]),t._v(" "),e("li",[t._v("最大请求数，浏览器限制了同域名下 http 请求的最大次数，因此超过这个数量都会进入等待队列，一旦对头阻塞，后面的请求都要等待。")]),t._v(" "),e("li",[t._v("HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接)(解决了队头阻塞的问题)，但是它要求请求返回还是按序的，因此还是有等待的问题。")])]),t._v(" "),e("h3",{attrs:{id:"http-2-的改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的改进","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP/2 的改进")]),t._v(" "),e("ul",[e("li",[t._v("采用二进制传输： HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，解析更加高效。引入帧和流的概念，帧是最小的单位，每个帧上头标识所属的流。流是链接中的一个虚拟通道。")]),t._v(" "),e("li",[t._v("多路复用：解决了浏览器限制同一个域名下的请求数量的问题。只发起一个TCP链接，数据流以消息的形式发送，消息又有多个帧组成，因为帧首部的流标识可以重新组装数据，因此帧之间可以乱序发送。当然也就可以并行交错的发送多个请求或响应，他们之间互不干扰，因此解决等待阻塞的问题。")]),t._v(" "),e("li",[t._v("首部压缩： 因为原来 HTTP 1.x 发送请求的同时可能会在首部携带上一些字段以及cookies,如果这个数据很大且重复。那么每次传输时就会造成资源浪费。因此 http2 采用了首部压缩的策略，在客户端与服务端同时存储一份首部字段表，每次传输时只携带新增的字段或者更新的字段，同时对端进行相应的同步。")]),t._v(" "),e("li",[t._v("服务端推送：也叫 cache push,  某些必须资源提前推送给客户端，减少请求的延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。主动推送也遵守同源策略，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。")])]),t._v(" "),e("h3",{attrs:{id:"http-3-新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-3-新特性","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP/3 新特性")]),t._v(" "),e("h4",{attrs:{id:"_1、改进之处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、改进之处","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、改进之处")]),t._v(" "),e("p",[t._v("虽然HTTP2 引入了多路复用技术，一个域名下只需使用一个TCP连接，极大的提升了效率。但是如果传输存在丢包的情况，那么整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了，性能反而不如开启多个 TCP 链接的 HTTP1.X。然而UDP 没有丢包重传的问题，因此基于UDP诞生了 QUIC 协议，并且使用在了 HTTP/3 上。")]),t._v(" "),e("h4",{attrs:{id:"_2、-quic-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、-quic-协议","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、 QUIC 协议")]),t._v(" "),e("ul",[e("li",[t._v("支持多路复用，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是 QUIC 是基于 UDP 的，一个连接上的多个stream之间没有依赖。即使出现某个 stream 丢包，其他的 stream 也可以正常传输，不存在阻塞的情况。")]),t._v(" "),e("li",[t._v("QUIC 是通过 设备ID 识别一个链接（TCP 是通过 IP）， 在移动端网络环境多变的环境下优势明显，通过 ID 迅速重连。")]),t._v(" "),e("li",[t._v("纠错机制，发送包的同时，也会带上一个校验包。如果出现丢包的请求，会根据校验包重新计算出丢失的数据，防止重传。当然如果丢失太多的话就没办法了。")])]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[t._v("HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷")]),t._v(" "),e("li",[t._v("HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的")]),t._v(" "),e("li",[t._v("QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议")])])])},[],!1,null,null,null);a.default=i.exports}}]);